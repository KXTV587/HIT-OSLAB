# 基于内核栈切换的进程切换

## 实验目的
深入理解进程和进程切换的概念；
综合应用进程、CPU管理、PCB、LDT、内核栈、内核态等知识解决实际问题；
开始建立系统认识。
## 实验内容
现在的Linux 0.11采用TSS（后面会有详细论述）和一条指令就能完成任务切换，虽然简单，但这指令的执行时间却很长，在实现任务切换时大概需要 200 多个时钟周期。而通过堆栈实现任务切换可能要更快，而且采用堆栈的切换还可以使用指令流水的并行优化技术，同时又使得CPU的设计变得简单。所以无论是 Linux还是 Windows，进程/线程的切换都没有使用 Intel 提供的这种TSS切换手段，而都是通过堆栈实现的。

本次实践项目就是将Linux 0.11中采用的TSS切换部分去掉，取而代之的是基于堆栈的切换程序。具体的说，就是将Linux 0.11中的switch_to实现去掉，写成一段基于堆栈切换的代码。

本次实验包括如下内容：

编写汇编程序switch_to：
完成主体框架；
在主体框架下依次完成PCB切换、内核栈切换、LDT切换等；
修改fork()，由于是基于内核栈的切换，所以进程需要创建出能完成内核栈切换的样子。
修改PCB，即task_struct结构，增加相应的内容域，同时处理由于修改了task_struct所造成的影响。
用修改后的Linux 0.11仍然可以启动、可以正常使用。
（选做）分析实验3的日志体会修改前后系统运行的差别。

## 实验步骤

> 所有修改文件都直接上传并链接了。部分文件不是自己写的（因为实在写不出来啊啊啊啊啊，能拼拼凑凑最后改出来已经谢天谢地了啊）

### 按要求修改文件[sched.h](https://github.com/KXTV587/HIT-OSLAB/tree/master/%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/%E5%AE%9E%E9%AA%8C4/sched.h),[sched.c](https://github.com/KXTV587/HIT-OSLAB/tree/master/%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/%E5%AE%9E%E9%AA%8C4/sched.c)

/linux-0.11/include/linux/sched.h
/linux-0.11/kernel/sched.c



### 修改[system_call.s](https://github.com/KXTV587/HIT-OSLAB/tree/master/%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/%E5%AE%9E%E9%AA%8C4/system_call.s)

kernel/system_call.s

### 修改[fork.c](https://github.com/KXTV587/HIT-OSLAB/tree/master/%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/%E5%AE%9E%E9%AA%8C4/fork.c)

kernel/fork.c

### 编译运行linux 0.11

注意是在乌班图下编译操作系统，用第一个实验的make all，而不是在bochs中编译，编译完成运行bochs，可以正常使用。

![t1](https://github.com/KXTV587/HIT-OSLAB/tree/master/%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/%E5%AE%9E%E9%AA%8C4/1.png)



