# 信号量的实现和应用

> 这个在操作系统课上学过，没想到实现起来这么麻烦…

## 实验目的
加深对进程同步与互斥概念的认识；
掌握信号量的使用，并应用它解决生产者——消费者问题；
掌握信号量的实现原理。
实验内容
本次实验的基本内容是：

在Ubuntu下编写程序，用信号量解决生产者——消费者问题；
在0.11中实现信号量，用生产者—消费者程序检验之。
用信号量解决生产者—消费者问题
### 在Ubuntu上编写应用程序“pc.c”，解决经典的生产者—消费者问题，完成下面的功能：

建立一个生产者进程，N个消费者进程（N>1）；
用文件建立一个共享缓冲区；
生产者进程依次向缓冲区写入整数0,1,2,...,M，M>=500；
消费者进程从缓冲区读数，每次读一个，并将读出的数字从缓冲区删除，然后将本进程ID和+ 数字输出到标准输出；
缓冲区同时最多只能保存10个数。
一种可能的输出效果是：
```
10: 0
10: 1
10: 2
10: 3
10: 4
11: 5
11: 6
12: 7
10: 8
12: 9
12: 10
12: 11
12: 12
……
11: 498
11: 499
```

其中ID的顺序会有较大变化，但冒号后的数字一定是从0开始递增加一的。

pc.c中将会用到sem_open()、sem_close()、sem_wait()和sem_post()等信号量相关的系统调用，请查阅相关文档。

### 实现信号量
Linux在0.11版还没有实现信号量，Linus把这件富有挑战的工作留给了你。如果能实现一套山寨版的完全符合POSIX规范的信号量，无疑是很有成就感的。但时间暂时不允许我们这么做，所以先弄一套缩水版的类POSIX信号量，它的函数原型和标准并不完全相同，而且只包含如下系统调用：
```
sem_t *sem_open(const char *name, unsigned int value);
int sem_wait(sem_t *sem);
int sem_post(sem_t *sem);
int sem_unlink(const char *name);
```
sem_t是信号量类型，根据实现的需要自定义。

sem_open()的功能是创建一个信号量，或打开一个已经存在的信号量。

name是信号量的名字。不同的进程可以通过提供同样的name而共享同一个信号量。如果该信号量不存在，就创建新的名为name的信号量；如果存在，就打开已经存在的名为name的信号量。 value是信号量的初值，仅当新建信号量时，此参数才有效，其余情况下它被忽略。 当成功时，返回值是该信号量的唯一标识（比如，在内核的地址、ID等），由另两个系统调用使用。如失败，返回值是NULL。 sem_wait()就是信号量的P原子操作。如果继续运行的条件不满足，则令调用进程等待在信号量sem上。返回0表示成功，返回-1表示失败。

sem_post()就是信号量的V原子操作。如果有等待sem的进程，它会唤醒其中的一个。返回0表示成功，返回-1表示失败。

sem_unlink()的功能是删除名为name的信号量。返回0表示成功，返回-1表示失败。

### 在kernel目录下新建“sem.c”文件实现如上功能。然后将pc.c从Ubuntu移植到0.11下，测试自己实现的信号量。

## 实验步骤

### 在linux/kernel下编写[em.c](https://github.com/KXTV587/HIT-OSLAB/tree/master/%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/%E5%AE%9E%E9%AA%8C5/sem.c),[sem.h](https://github.com/KXTV587/HIT-OSLAB/tree/master/%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/%E5%AE%9E%E9%AA%8C5/sem.h)并编译操作系统

### 编写[pc.c](https://github.com/KXTV587/HIT-OSLAB/tree/master/%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/%E5%AE%9E%E9%AA%8C5/pc.c),[producer.c](https://github.com/KXTV587/HIT-OSLAB/tree/master/%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/%E5%AE%9E%E9%AA%8C5/producer.c),[customer.c](https://github.com/KXTV587/HIT-OSLAB/tree/master/%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/%E5%AE%9E%E9%AA%8C5/customer.c)并移植到linux0.11下

代码实现比较复杂，参考了很多地方，但是pv操作在操作系统课上学过。

p操作申请，v操作释放，对于信号灯变量只能进行这两种操作。

#### 教程中提到：

> 在pc.c中去掉所有与信号量有关的代码，再运行程序，执行效果有变化吗？为什么会这样？ 实验的设计者在第一次编写生产者——消费者程序的时候，是这么做的：
```
Producer()
{
    P(Mutex);  //互斥信号量
    生产一个产品item;
    P(Empty);  //空闲缓存资源
    将item放到空闲缓存中;
    V(Full);  //产品资源
    V(Mutex);
}

Consumer()
{
    P(Mutex);  
    P(Full);  
    从缓存区取出一个赋值给item;
    V(Empty);
    消费产品item;
    V(Mutex);
} 
```
> 这样可行吗？如果可行，那么它和标准解法在执行效果上会有什么不同？如果不可行，那么它有什么问题使它不可行？

我认为不可行，明显要把producer与customer写到两个文件里，才能多线程的调用他们，来共享一个信号灯。都放在一个文件里可能会出问题。

（但是正因为如此我就是调用不好…结果就没做出实验结果来……………………）

但是我还是比较确定这个思路应该是正确的。

#### 调用使用下面的方法

多进程共享文件
在Linux下使用C语言，可以通过三种方法进行文件的读写：

使用标准C的fopen()、fread()、fwrite()、fseek()和fclose()等；
使用系统调用open()、read()、write()、lseek()和close()等；
通过内存镜像文件，使用mmap()系统调用。
在Linux 0.11上只能使用前两种方法。
fork()调用成功后，子进程会继承父进程拥有的大多数资源，包括父进程打开的文件。所以子进程可以直接使用父进程创建的文件指针/描述符/句柄，访问的是与父进程相同的文件。

使用标准C的文件操作函数要注意，它们使用的是进程空间内的文件缓冲区，父进程和子进程之间不共享这个缓冲区。因此，任何一个进程做完写操作后，必须fflush()一下，将数据强制更新到磁盘，其它进程才能读到所需数据。

建议直接使用系统调用进行文件操作。

（也是我没能明白的部分…）

### 在bochs中测试程序

编写[test.c](https://github.com/KXTV587/HIT-OSLAB/tree/master/%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/%E5%AE%9E%E9%AA%8C5/test.c)

编译并测试。

以下是测试结果：

![T1](https://github.com/KXTV587/HIT-OSLAB/tree/master/%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE%E7%89%87/%E5%AE%9E%E9%AA%8C5/1.png)

> 这个实验未能自己跑出结果，可能是pc对其他的函数调用出现了问题，使用了别人的实验结果图。

## 参考博客

https://blog.csdn.net/u013129143/article/details/83755904
